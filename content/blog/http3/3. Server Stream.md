---
date: '2025-05-22T21:50:25+02:00'
title: 'Server Stream'
description: "Server-side streaming with HTTP/3 in Go."
slug: 'server-stream'
showToc: true
tags:
  - HTTP3
---

> Previous parts:
> - [Writing HTTP3 Server](/blog/http3/http3-server/)
> - [HTTP3 Client](/blog/http3/http3-client)

Learn how to implement server-side streaming with HTTP/3 - a powerful technique for video streaming, large file transfers, and real-time data updates.

## Server

Let's start by implementing an HTTP/3 server. For reference, check out [Writing HTTP3 Server](/blog/http3/http3-server/).
To implement streaming from the server, we take over the HTTP/3 stream and use it to send data to a client.

We'll use [`http3.HTTPStreamer`](https://pkg.go.dev/github.com/quic-go/quic-go@v0.51.0/http3#HTTPStreamer), which is implemented by `http.ResponseWriter`. When a stream is taken over, it's the caller's responsibility to close the stream, so don't forget to close it with `defer`.

```go
mux := http.NewServeMux()
mux.HandleFunc("/stream", func(w http.ResponseWriter, r *http.Request) {
    // take over the HTTP/3 stream
    streamer := w.(http3.HTTPStreamer)
    http3Stream := streamer.HTTPStream()
    defer http3Stream.Close()
    ...
```

Now that we have our stream, let's send some data:

```go
mux := http.NewServeMux()
mux.HandleFunc("/stream", func(w http.ResponseWriter, r *http.Request) {
    // taking over the HTTP/3 stream
    streamer := w.(http3.HTTPStreamer)
    http3Stream := streamer.HTTPStream()
    defer http3Stream.Close()
    // sending data to the stream
    for i := range 100 {
        fmt.Fprintf(http3Stream, "Hello %d\n", i)
        time.Sleep(100 * time.Millisecond) // simulating work
    }
})
```

And run the server itself:

```go
srv := &http3.Server{
    // listen on port 8080
    Addr:    "127.0.0.1:8080",
    Handler: mux,
}
// path to generated cert and key
if err := srv.ListenAndServeTLS("cert.pem", "key.pem"); err != nil {
    panic(err)
}
```

## Client

Now we need something to read our data.
On the client side, we'll load the server's TLS certificate, as we did [previously](/blog/http3/http3-client/#trusting-servers-tls-certificate):

```go
certPool := x509.NewCertPool()
certData, err := os.ReadFile("cert.pem")
if err != nil {
    panic(err)
}
certPool.AppendCertsFromPEM(certData)
```

Next, create an HTTP client:

```go
client := &http.Client{
    Transport: &http3.Transport{
        TLSClientConfig: &tls.Config{
            RootCAs: certPool, // use the cert pool with the server's cert
        },
    },
}
```

Then, call the server and print out the response it returns.

```go
resp, err := client.Get("https://localhost:8080/stream")
if err != nil {
    panic(err)
}
defer resp.Body.Close()
// read the response body
if _, err := io.Copy(os.Stdout, resp.Body); err != nil {
    panic(err)
}
```

If you run all of this together, you'll see a stream of data coming in with slight delays (because the server simulates work with a short sleep between messages):

```
$ go run ./serverstream.go
Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
Hello 5
Hello 6
...
```

{{< details summary="Full code" >}}
```go
// serverstream.go
package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"github.com/quic-go/quic-go/http3"
)

func main() {
	go runServer()
	certPool := x509.NewCertPool()
	certData, err := os.ReadFile("cert.pem")
	if err != nil {
		panic(err)
	}
	certPool.AppendCertsFromPEM(certData)

	client := &http.Client{
		Transport: &http3.Transport{
			TLSClientConfig: &tls.Config{
				RootCAs: certPool, // use the cert pool with server's cert
			},
		},
	}
	resp, err := client.Get("https://localhost:8080/stream")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	// read the response body
	if _, err := io.Copy(os.Stdout, resp.Body); err != nil {
		panic(err)
	}
}

func runServer() {
	mux := http.NewServeMux()
	mux.HandleFunc("/stream", func(w http.ResponseWriter, r *http.Request) {
		// taking over the HTTP/3 stream
		streamer := w.(http3.HTTPStreamer)
		http3Stream := streamer.HTTPStream()
		defer http3Stream.Close()
		// sending data to the stream
		for i := range 100 {
			fmt.Fprintf(http3Stream, "Hello %d\n", i)
			time.Sleep(100 * time.Millisecond)
		}
	})
	srv := &http3.Server{
		// listen on the port 8080
		Addr:    "127.0.0.1:8080",
		Handler: mux,
	}
	// path to generated cert and key
	if err := srv.ListenAndServeTLS("cert.pem", "key.pem"); err != nil {
		panic(err)
	}
}
```

{{< /details >}}

That's it â€” you are amazing! ðŸ’…

## Recap

In this post, we learned how to implement real-time streaming over HTTP/3, including setting up both the server and client and efficiently sending data as it becomes available.
