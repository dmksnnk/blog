package main

import (
	"compress/gzip"
	"net/http"
	"path/filepath"
	"strings"
)

func GzipMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
			next.ServeHTTP(w, r)
			return
		}

		ext := filepath.Ext(r.URL.Path)
		switch ext { // "" is for directories, default to index.html
		case "", ".html", ".css", ".js", ".json", ".xml", ".svg":
			w.Header().Set("Content-Encoding", "gzip")
			grw := newGzipResponseWriter(w)
			defer grw.Close()
			next.ServeHTTP(grw, r)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func CacheMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check if the request is cacheable
		if r.Method != http.MethodGet {
			next.ServeHTTP(w, r)
			return
		}

		ext := filepath.Ext(r.URL.Path)
		switch ext {
		case ".css":
			// Files CSS generated by hugo with a hash in the name (stylesheet.a1a2...css) (fingerprinting).
			// These can be cached aggressively for a long time.
			w.Header().Set("Cache-Control", "public, max-age=31536000, immutable")
		case ".js", ".json", ".xml", ".svg": // store for a day
			w.Header().Set("Cache-Control", " public, max-age=86400")
		case ".png": // PNG files are fingerprinted and can be cached for a long time
			w.Header().Set("Cache-Control", "public, max-age=31536000")

		}

		// Set cache headers
		next.ServeHTTP(w, r)
	})
}

func newGzipResponseWriter(rw http.ResponseWriter) *gzipResponseWriter {
	gz := gzip.NewWriter(rw)
	return &gzipResponseWriter{
		ResponseWriter: rw,
		w:              gz,
	}
}

type gzipResponseWriter struct {
	http.ResponseWriter
	w *gzip.Writer
}

func (rw gzipResponseWriter) Write(b []byte) (int, error) {
	return rw.w.Write(b)
}

func (rw gzipResponseWriter) Close() error {
	return rw.w.Close()
}
